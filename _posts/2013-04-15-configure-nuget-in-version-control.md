---
layout: post
title: "Configure NuGet in Version Control"
tags: ["nuget", "tfs", "version control"]
---

<div class="message">
When enjoying the convenience NuGet brings us, it is easy to forget the fact that the references will come back to bite you the hardest, specially when working with version control.
</div>

This time, I hit a jackpot checkout my project from TFS in a new device, and realise all my dependencies all gong like they never existed, only leaving the NuGet config file proving I wasn't day dreaming before.

This actually prevents me from using `Ninject.MVC3` like I used to do in MVC 3. Even more unfortunately is that Ninject package for MVC 4 is not out yet, that why this alternative solution is used.

Therefore, I would highly recommend the following practices for the people who'd like to keep their project clean and tidy: no unnecessary package or exes checked in, but still be able to use the dependencies when the project is checked out.

#Enabling package restore during build in Visual Studio options

{% include image.html url="/media/2013-04-15-configure-nuget-in-version-control/configurenuget-01.png" width="100%" description="Enable package restore in options" %}

#Enabling package restore in solution

{% include image.html url="/media/2013-04-15-configure-nuget-in-version-control/configurenuget-02.png" width="100%" description="Enable package restore in solution" %}

And you should be able to see this

{% include image.html url="/media/2013-04-15-configure-nuget-in-version-control/configurenuget-03.png" width="100%" description="Files generated by enabling pakcage restore" %}

But it is not the end of the story, simply because you don't want to break the rules to check in any .dll or .exe.

#Force NuGet.exe to download whenever needed

 Open up `NuGet.targets`, find `DownloadNuGetExe`, and set the value to `true`.

{% highlight xml %}
<!-- Download NuGet.exe if it does not already exist -->
<DownloadNuGetExe Condition=" '$(DownloadNuGetExe)' == '' ">true</DownloadNuGetExe>
{% endhighlight %}

#Configure proxy to allow download

If you are working within an enterprise network, the auto-download of 'nuget.exe' might not work. In which case, you will have to configure a proxy for it.

Open up `NuGet.targets` again, find task `DownloadNuGet`, and configure the snippet with your proxy and credentials.

{% highlight xml %}
<Code Type="Fragment" Language="cs">
    <![CDATA[
    try {
        WebProxy proxy = new WebProxy(<proxy address>, <port>);
        proxy.Credentials = new NetworkCredential(<user name>, <password>, <domain>);
        OutputFilename = Path.GetFullPath(OutputFilename);

        Log.LogMessage("Downloading latest version of NuGet.exe...");
        WebClient webClient = new WebClient();
        webClient.Proxy = proxy;
        webClient.DownloadFile("https://nuget.org/nuget.exe", OutputFilename);

        return true;
    }
    catch (Exception ex) {
        Log.LogErrorFromException(ex);
        return false;
    }
]]>
</Code>
{% endhighlight %}

#Some more tips

To keep things neat and tidy, you can now delete the 'packages' folder, because that is the whole point of doing this, right? To remove the redundant dependency files, which saves not just space but also time checking out or cloning depends on what version control mechanism you use, instead allowing build event to retrieve them back automatically.

You can now check in the changes to TFS, and you will find your TFS build server and your check out are working again!

#References

- [Using Nuget without committing packages](http://docs.nuget.org/docs/workflows/using-nuget-without-committing-packages)

- [Prevent needing to add nuget.exe to source control](http://stackoverflow.com/questions/12022154/prevent-needing-to-add-nuget-exe-to-source-control)
